{{Header}}
{{#seo:
|description=Generating Strong Passwords
|og:image=https://www.whonix.org/w/images/b/b6/Passwords2132341.jpg
}}

{{Maintainer|
|status=stable
|about=About this {{Code2|{{PAGENAME}}}} Page
|difficulty=easy
|maintainer=[https://forums.whonix.org/users/hulahoop HulaHoop]
|support=[[Support]]
}}

= Introduction =

{{mbox
| image   = [[File:Ambox_warning_pn.svg.png|40px]]
| text       = '''Warning:''' Nation-state adversaries were reported to have been capable of conducting password brute-forcing attempts at one trillion guesses per second back in 2013. Considering Moore's Law it could have only improved since.<ref>https://www.password-depot.com/know-how/brute-force-attacks.htm</ref> <ref>https://theintercept.com/2015/03/26/passphrases-can-memorize-attackers-cant-guess/</ref>
}}


If weak passwords (passphrases) are used, they will be easily discovered by trying every possible character combination, in reasonable time through [https://en.wikipedia.org/wiki/Brute-force_attack brute-force attacks]. This method is very fast for short and/or non-random passwords.

= Generating Unbreakable Passwords =

== Introduction ==

To generate strong passwords that are both easy to remember and have an easily calculatable large entropy, it is advised to use the Diceware package. Instead of generating a random sequence containing alphanumerical and special characters, Diceware selects a sequence of words equiprobably from a list containing several thousands that have been curated for their memorability, length and profanity. Passphrases long enough should be safe for millions or billions of years even if the list chosen is known to the attacker. It relies on the fact that the time to try all possible combinations would be infeasibly large even for a well equipped adversary. <ref>https://en.wikipedia.org/wiki/Diceware</ref><ref>https://en.wikipedia.org/wiki/Password_strength#Random_passwords</ref> In the next sections we will discuss how to calculate entropy for both pre-quantum and post-quantum strength, how to estimate how long it takes to brute force a passphrase and measures to aid in making passphrase length manageable in a post-quantum world with the use of key-stretching.

== Diceware Password Strength ==

When determining a passphrase length, ideally you want the passphrase to have at least as much entropy as the bit length of the symmetric key that is derived from it.<ref>https://www.whonix.org/pipermail/whonix-devel/2018-August/001184.html</ref> As will be explained later, one can deviate from this rule to have a shorter passphrase while still having a realistically strong protection level.

[http://world.std.com/~reinhold/dicewarefaq.html#entropy Entropy] per word is calculated by dividing log of number of words in list by log 2. List lengths vary.

EFF list:

<pre>
log (7776) / log (2) = 12.92 bits
</pre>


SecureDrop list:

<pre>
log (6800) / log (2) = 12.73 bits
</pre>


Total passphrase entropy is: 

<pre>
number of words * entropy per word
</pre>


There are 32 special characters on a standard U.S. keyboard
<pre>
log (32) / log (2) = 5 bits per character
</pre>


Entropy in the table below can be defined as: 

'''Table:''' ''Diceware Password Strength'' <ref>https://www.rempe.us/diceware/#eff</ref>

{| class="wikitable"
|-
! scope="col"| Word Total
! scope="col"| Bits of Entropy
! scope="col"| Estimated Brute-force Time (Classical Computing) <ref>One trillion guesses per second.</ref>
! scope="col"| Future-proof Safety <ref>Safe until at least the year 2050.</ref>
! scope="col"| [[PQCrypto|Post-quantum]] Secure <ref>Assuming [https://en.wikipedia.org/wiki/Grover%27s_algorithm Grover's algorithm] halves the number of iterations required to brute-force a key. This means doubling the length of symmetric keys to protect against future (hypothetical) quantum attacks.</ref>
|-
! scope="row"| Five
| ~64
| ~165 days
| {{No}}
| {{No}}
|-
! scope="row"| Six
| ~78
| ~3,505 years
| style="background-color: {{Yellow}}" | Maybe
| {{No}}
|-
! scope="row"| Seven
| ~90
| ~27,256 millennia
| {{Yes}}
| {{No}}
|-
! scope="row"| Eight
| ~103
| ~15 x age Universe
| {{Yes}}
| {{No}}
|-
! scope="row"| Nine
| ~116
| ~119,441 x age Universe
| {{Yes}}
| {{No}}
|-
! scope="row"| Ten
| ~129
| ~928,773,415 x age Universe
| {{Yes}}
| {{No}}
|-
! scope="row"| Fifteen
| ~194
| ~26,405,295,715,806,668,059,525,829,264 x age Universe
| {{Yes}}
| {{Yes}}
|-
! scope="row" | Twenty
| ~259
| ~750,710,162,715,852,378,145,230,792,130,183,941,981,164,925,924 x age Universe
| {{Yes}}
| {{Yes}}
|-
|}

== Calculating Brute-force Time ==

[https://en.wikipedia.org/wiki/Moore%27s_law Moore's Law] predicts the doubling of number of on-die transistors every 24 months (two years). Other estimates by the industry put that at 18 months. It is expected that Moore's Law ends by 2025 because of physical constraints of silicon.

1 trillion guesses in 2013 = 2^40 operations

Lower bound - Doubling every 24 months 2013-2025:
<pre>
2^46
</pre>


Upper bound - Every 18 months 2013-2025:
<pre>
2^48
</pre>


Gauging strength against adversary capabilities:

Example: An 80 bit passphrase vs adversary with 1 trillion or (2^40 guesses per second)
<pre>
2^(80-40) = 2^40 seconds
</pre>


Which you then divide by 31536000 seconds / year to get number of years.<ref>https://security.stackexchange.com/questions/69374/is-an-80-bit-password-good-enough-for-all-practical-purposes/69378</ref><ref>https://security.stackexchange.com/a/115397</ref>

== Classical vs Quantum Computing ==

'''Classical Computing Attack'''
* Diceware passphrases of 7 words recommended yielding ~90 bits of entropy against classical computing attacks.<ref>https://theintercept.com/2015/03/26/passphrases-can-memorize-attackers-cant-guess/</ref>
* Passphrases of 10 words have 128 bits of entropy.


'''Quantum Computing Attack'''
* Grover’s quantum search algorithm halves the key search space, so all entropy values in the table above are halved on quantum computers. For example the cost of searching the right passphrase of a 2^128 passphrase drops to (very) roughly ~2^64.<ref>https://www.whonix.org/pipermail/whonix-devel/2018-August/001184.html</ref> 
* A 20 word passphrase with 2^256 bit entropy today, yields 128 bit post-quantum protection.
* Quantum computers do '''not''' impact the entropy provided by key-stretching algorithms. See below.<ref>https://www.whonix.org/pipermail/whonix-devel/2018-August/001215.html</ref>


= Key-Stretching =

Key-stretching, depending on how it's implemented, introduces a major speed-bump for brute-forcing as it forces an adversary to undergo extra steps compared to processing vanilla symmetric master encryption keys. They allow passphrases to be shorter while adding a certain entropy security margin. Note this does not help you if you use bad passwords.

Passphrases for LUKS FDE are secured using a key-stretching implementation known as a Password-Based Key Derivation Function (PBKDF). The older HMAC-SHA* algorithm is less effective against parallelization by GPUs and ASICs (the same weaknesses suffered by Bitcoin against dedicated mining hardware).

Argon2id is the winner of the [https://en.wikipedia.org/wiki/Password_Hashing_Competition Password Hashing Competition] and the state-of-the-art hashing algorithm of choice when protecting encryption keys. Its memory-hard properties introduce a large penalty for brute-search on general computers and even more so on GPUs and ASICs.


== Choosing Parameters ==

Calculating entropy for Argon2id. An example<ref>https://www.whonix.org/pipermail/whonix-devel/2018-September/001255.html</ref> using arbitrary parameters below:

1 GiB RAM, 50 iterations and 4 threads

m=1GiB, t=50, p=4

The "20" comes from the exponent of 2 that gives number of kilobytes in 1 GiB RAM amount used (2^20 = 1048576 in this case). We care about the number of 1 KiB block operations. For 4 GiB, the exponent becomes "22" (2^22 = 4194304).

'''General Computers "Lower Bound"'''
<pre>
20 + (log (50) / log(2)) = ~26 bits
</pre>


'''GPUs and ASICs "Higher Bound"'''
<pre>
20 + (20 - (log (8*4) / log (2))) + (log (50) / log (2)) = ~41 bits
</pre>

Subtracting the parallelism (8x within a block and 4x thread-level p=4),
because for this sort of attacks the parallelism reduces the duration
for which the memory has to be occupied.


'''Comments'''<ref>https://www.whonix.org/pipermail/whonix-devel/2018-September/001255.html</ref>

<pre>
Then, I think t=50 is excessive.  It isn't even the equivalent of a one
word longer passphrase, but it takes more time than typing a word would.

Perhaps you should consider t=3.  That will be only "4 bits" less,
giving you something like 22 to 40 bits (depending on attack hardware)
of stretching relative to BLAKE2b.

--SolarDesigner (OpenWall lead and cryptographer who participated in Password Hashing Competition)
</pre>


== Migrating LUKS FDE to Argon2id == 

These steps are to migrate currently LUKS encrypted systems first from LUKS1 to LUKS2 header then shifting to Argon2id. Removable media migration should be straight forward, however the main running system will require extra pre-boot steps as an open encrypted volume cannot be modified.<ref>https://www.saout.de/pipermail/dm-crypt/2018-September/005974.html</ref> Take precautions such as backing up your data and make a copy of the required steps since they will be inaccessible during part of the process.

Enumerate all devices to determine partition name:
{{CodeSelect|code=
# ls /dev/
}}


Verify the partition in question is an encrypted one (sda5 typically on default non-customized installs):
{{CodeSelect|code=
# blkid -p /dev/sda5
}}


To see details about the LUKS header and to confirm it was converted in the end:
{{CodeSelect|code=
# cryptsetup luksDump --debug /dev/sda5
}}


Before rebooting you might want to make sure the ‘algif_skcipher’ kernel
module is included in the initramfs image, otherwise you might not be
able to open LUKS2 volumes.  (See https://bugs.debian.org/896968 for
details.)  To do so, run the following two commands:
<pre>
# echo algif_skcipher | sudo tee -a /etc/initramfs-tools/modules
sudo update-initramfs -u
</pre>


Now assuming your bootloader is GRUB, reboot, press <E> to obtain an
emacs-like screen, append “ break=premount” to the line starting with
“linux”, and press <code>Ctrl</code>+<code>X</code> to boot. (The edit is transient and won't survive the next reboot). You should land into an initramfs debug shell

Convert header to LUKS2:
{{CodeSelect|code=
cryptsetup convert /dev/sda5 --type luks2 --debug
}}


Convert to Argon2id. Parameters of 1 GiB RAM, 50 iterations and 4 threads in this example:
{{CodeSelect|code=
cryptsetup luksConvertKey --key-slot 0 --pbkdf argon2id --pbkdf-force-iterations 50 --pbkdf-memory 1048576 --pbkdf-parallel 4 /dev/sda5
}}

= Guidelines =

Note: post-quantum era words are 6.46 bits each.

For LUKS FDE where memorization is a burden (assuming EFF list and 26 bit Argon2id lower bound):

[post-quantum] 10 words + Argon2id = ~90 bits 

[post-quantum] 11 words + Argon2id = ~97 bits

[post-quantum] 12 words + Argon2id = ~103 bits


For LUKS FDE where memorization is a burden (assuming EFF list and 24 bit Argon2id lower bound for faster logins [configured by 4 GiB, 3 iterations, 4 threads]):

[post-quantum] 10 words + Argon2id = ~88 bits 

[post-quantum] 11 words + Argon2id = ~95 bits

[post-quantum] 12 words + Argon2id = ~102 bits


Summary: 12 words is the safest compromise, giving a comfortable security margin at mild cognitive expense.


For any other encrypted media/container that does not implement Argon2id or where memory is not a problem because you can safely store the password on your encrypted computer:

[post-quantum] 20 words = 128 bits


Alternatively if memorization is not a problem in the case of non-system media, you can use a shorter alphanumeric string consisting of 43 characters to achieve 128 bit post-quantum strength:<ref>https://pthree.org/2011/03/07/strong-passwords-need-entropy/</ref><ref>https://unix.stackexchange.com/questions/230673/how-to-generate-a-random-string</ref>

<pre>
head /dev/random | tr -dc A-Za-z0-9 | head -c 43 ; echo ''
</pre>


== Passphrase Generation ==

For all practical purposes using the Linux RNG is sufficient for selecting words in a random fashion. You can go one step further and use dice to physically choose the words with Diceware.<ref>http://world.std.com/%7Ereinhold/dicewarefaq.html</ref>

The [https://tracker.debian.org/pkg/diceware "diceware" package] is available in Debian (and in later Whonix versions by default).

To generate a 12 word passphrase from the EFF's list, run:

{{CodeSelect|code=
diceware -n 12 -w en_eff
}}

=== Additional Tips ===

Follow this additional advice for Diceware passphrases: <ref>http://world.std.com/~reinhold/dicewarefaq.html#</ref>

* Diceware passphrases ''should'' have spaces between each word, otherwise the strength of the passphrase is materially weakened. For example, a six-word passphrase without spaces “stray clam my aloof micro judo” has the same strength as a five-word passphrase “stray clammy aloof micro judo” with spaces.
* Only change passphrases if a compromise is suspected.
* Random character capitalization is ''not'' recommended. Although it adds 1 bit per character, it requires regular pressing of the shift key - slowing down typing and increasing the number of keystrokes. Instead, it is better to just make the passphrase longer if additional entropy is required.

= Principles for Stronger Passwords =

Users should read [https://en.wikipedia.org/wiki/Password_strength#Examples_of_weak_passwords Wikipedia: Weak Passwords] to learn about better practices for generating strong passwords, and to determine if current passwords are weak. ([http://www.webcitation.org/6EUz4uxz8 w]). The general principles for stronger passwords are outlined below. <ref>https://en.wikipedia.org/wiki/Password_strength#Guidelines_for_strong_passwords</ref> The human mind is notoriously bad at coming up with truly random passwords.<ref>https://www.schneier.com/blog/archives/2017/05/nsa_brute-force.html#c6753142 "The last time I sat down to work out the statistics from known password lists the initial letter of a password/phrase had less than 4bits of entropy which rapidly dropped to less than 1.5bits by the seventh character, and dropping to a little over 1bit after ten characters.

The simple fact is computers are now faster and more adept at password cracking than humans can think up memorable ways to remember strings of information that to humans look random..." --Clive Robinson</ref><ref>https://security.stackexchange.com/questions/6095/xkcd-936-short-complex-password-or-long-dictionary-passphrase Second reply</ref>

== Content and Length ==

* '''Avoid Dictionary-based Passwords:''' It is unsafe to use passwords that are dependent on dictionary words, keyboard patterns, special letter or number sequences, usernames, phrases from anything read or seen, relative or pet names, biographical information, or persons known to the user.

* '''Avoid Short Passwords:''' Passwords should not be less than 12-14 characters in length; longer passwords are exponentially more difficult to crack than shorter ones. <ref>https://www.password-depot.com/know-how/brute-force-attacks.htm</ref>

* '''Generate True Password Randomness:''' Random passwords require the use of specialized tools like Diceware. The human brain is poor at creating passwords which are both easy to memorize and also secure.

* '''Online Services vs FDE:''' Passwords used for online services do not need to be extremely long, since the server rate-limits how many passwords an attacker can attempt. However, passwords used for offline encryption such as full disk encryption should be far stronger, since the threat model is different. An attacker can parallelize brute-forcing the password and is only limited by available system resources. Edward Snowden estimated in 2013 that serious adversaries are capable of one trillion guesses per second. <ref>https://theintercept.com/2015/03/26/passphrases-can-memorize-attackers-cant-guess/</ref>

== Poor Habits ==

* '''Avoid Personal Information:''' Any information that might be publicly linked to the user or the user's account, or which is known by friends or acquaintances, should never be used for passwords.

* '''Avoid <u>SMS-based</u> Two-factor Authentication:''' Contrary to conventional wisdom, SMS-based [[2FA]] gives away a user's identity, and also makes it easier for third parties to break into an account; for example, by performing sim-cloning or conducting social engineering attacks on the cellular provider. <ref>https://www.wired.com/2016/06/hey-stop-using-texts-two-factor-authentication/</ref>

* '''Do not Re-use Passwords:''' Even slight variations of a password allows the linking of multiple identities back to an individual. Attackers can use these discoveries to make templates which do not completely rely on brute-force attacks.

* '''Never Use Online Password Generators:''' These tools are only useful for satisfying curiosity or additional learning, since it is possible for the server to log the passwords. The only place where passwords should be generated is locally, and ideally by using physical measures (like dice) or via software in a VM disconnected from the Internet.

== Storage ==

* '''Password Managers:''' Consider using a [https://www.keepassx.org/ secure password manager], so hundreds of different passwords can be kept stored in an encrypted password database. Access only requires one master password, which should be cryptographically strong to protect the contents.

* '''Physical Records:''' If passwords are written down, they should be stored securely and not be left in obvious places.

= Forum Discussion =
https://forums.whonix.org/t/password-advice-wiki-page-enhancements

= See Also =
* [[Two-factor_authentication_2FA|Two-factor authentication (2FA)]]

= Footnotes =
{{reflist|close=1}}

{{Footer}}

[[Category:Documentation]]
